# 二分法

> 思考关键的问题而不是记公式：
>
> - 当target和当前指向值相比较小时，答案是否存在？较大时如何？由此选择新的范围；
> - 最终结果是在[0, n)还是[0, n]区间内？由此选择right的初始值；
> - 左右相等时是否还需要判断？由此决定循环中的等号是否被取到；
> - left和right以及mid的意义何在？由此决定返回的是谁。

### 解题步骤

1. 确定循环不变式：
   1. 每次迭代中结果一定在[left, right]（开/闭？）的区间内；
   2. left和right的数组值和target的关系；
2. 二分移动的条件是什么？
   1. mid是不是解；
   2. 是否指针需要+1或-1；
3. 截止条件是什么？
   1. 范围压缩到很小的解；
   2. 避免死循环；
4. 用循环不变式证明正确性：
   1. 初始状态下，循环不变式是否正确；
   2. 循环过程中，循环不变式是否保持；
   3. 循环结束时，循环不变式是否成立。

### 个人思考

- 其实在比较麻烦的环境下，我认为可以退而求其次：
  - 在确定答案已经位于某一个较小区间之后，遍历求解。这样做是确定成本最小的。

### 无重复，找不到返回-1

```cpp
int searchEqual(vector<int> nums, int target) {
    int left = 0, right = nums.size() - 1, res;
    while(left < right) {
        res = left + (right - left) / 2;
        if(nums[res] == target)
            return res;
        if(nums[res] < target)
            left = res + 1;
        else
            right = res - 1;
    }
    return -1;
}
```

### 无重复，找不到返回插入点（第一个大于等于x的数的位置）

```cpp
int searchFirstBiggerOrEqual(vector<int> nums, int target) {
    int left = 0, right = nums.size(), res;
    while(left <= right) {
        res = left + (right - left) / 2;
        if(nums[res] == target)
            return res;
        if(nums[res] < target)
            left = res + 1;
        else
            right = res - 1;
    }
    return left;
}
```

### 允许重复，找到第一个相等

```cpp
int searchFirstEqual(vector<int> nums, int target) {
    int left = 0, right = nums.size(), res;
    while(left < right) {
        res = left + (right - left) / 2;
        if(nums[res] == target)
            right = res;
        if(nums[res] < target)
            left = res + 1;
        else
            right = res - 1;
    }
    return nums[left] == target ? left : -1;
}
```

### 允许重复，找到最后一个相等

```cpp

```

